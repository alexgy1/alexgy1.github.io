<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Eleven network questions | alex&#39;s Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="1 为什么 tcp 需要握手机制， 为什么需要三次？ 两次 四次不行么？  为什么需要握手？  TCP 的可靠性 反映出 双方如何知道对方发过去消息了？ 交换对方的 increase number 对方收到后加一 再发回去, 不丢包， 消息未成功发送会再次发送机制来确保可靠性。 tcp 是双向的 客户端和服务器端 是双工的 可以互相发消息， 和单工的区别就是 http 协议和 tcp 协议。 http 协议是单工的， 请求-应答模型，而且只能客户端发起请求，服务器端应答，客户端发起请求， 服务器端收到请求后再应答 tcp 是 client server 都可以给对方发消息， 当同时发的时候就需要知道对方的消息的序列号，否则就没法恢复说你收到了哪些消息， 序列号不能从零开始，是根据一些手段随机生成的 为了获取序列号 所以握手   为什么是三次握手？  Alice ---&gt; Bob SYNchronize with my Initial Sequence Number of X Alice &lt;--- Bob I received your syn, I ACKnowledge that I am ready for [X&#43;1] Alice &lt;--- Bob SYNchronize with my Initial Sequence Number of Y Alice ---&gt; Bob I received your syn, I ACKnowledge that I am ready for [Y&#43;1] Notice, four events are occurring: 1.">
    <meta name="generator" content="Hugo 0.78.2" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    

  
  
    <link rel="stylesheet" href="/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css" >
  




    
      

    

    
    
    <meta property="og:title" content="Eleven network questions" />
<meta property="og:description" content="1 为什么 tcp 需要握手机制， 为什么需要三次？ 两次 四次不行么？  为什么需要握手？  TCP 的可靠性 反映出 双方如何知道对方发过去消息了？ 交换对方的 increase number 对方收到后加一 再发回去, 不丢包， 消息未成功发送会再次发送机制来确保可靠性。 tcp 是双向的 客户端和服务器端 是双工的 可以互相发消息， 和单工的区别就是 http 协议和 tcp 协议。 http 协议是单工的， 请求-应答模型，而且只能客户端发起请求，服务器端应答，客户端发起请求， 服务器端收到请求后再应答 tcp 是 client server 都可以给对方发消息， 当同时发的时候就需要知道对方的消息的序列号，否则就没法恢复说你收到了哪些消息， 序列号不能从零开始，是根据一些手段随机生成的 为了获取序列号 所以握手   为什么是三次握手？  Alice ---&gt; Bob SYNchronize with my Initial Sequence Number of X Alice &lt;--- Bob I received your syn, I ACKnowledge that I am ready for [X&#43;1] Alice &lt;--- Bob SYNchronize with my Initial Sequence Number of Y Alice ---&gt; Bob I received your syn, I ACKnowledge that I am ready for [Y&#43;1] Notice, four events are occurring: 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://alexgy1.github.io/posts/eleven-network-questions/" />
<meta property="article:published_time" content="2021-02-21T14:33:00+08:00" />
<meta property="article:modified_time" content="2021-02-21T14:33:00+08:00" />
<meta itemprop="name" content="Eleven network questions">
<meta itemprop="description" content="1 为什么 tcp 需要握手机制， 为什么需要三次？ 两次 四次不行么？  为什么需要握手？  TCP 的可靠性 反映出 双方如何知道对方发过去消息了？ 交换对方的 increase number 对方收到后加一 再发回去, 不丢包， 消息未成功发送会再次发送机制来确保可靠性。 tcp 是双向的 客户端和服务器端 是双工的 可以互相发消息， 和单工的区别就是 http 协议和 tcp 协议。 http 协议是单工的， 请求-应答模型，而且只能客户端发起请求，服务器端应答，客户端发起请求， 服务器端收到请求后再应答 tcp 是 client server 都可以给对方发消息， 当同时发的时候就需要知道对方的消息的序列号，否则就没法恢复说你收到了哪些消息， 序列号不能从零开始，是根据一些手段随机生成的 为了获取序列号 所以握手   为什么是三次握手？  Alice ---&gt; Bob SYNchronize with my Initial Sequence Number of X Alice &lt;--- Bob I received your syn, I ACKnowledge that I am ready for [X&#43;1] Alice &lt;--- Bob SYNchronize with my Initial Sequence Number of Y Alice ---&gt; Bob I received your syn, I ACKnowledge that I am ready for [Y&#43;1] Notice, four events are occurring: 1.">
<meta itemprop="datePublished" content="2021-02-21T14:33:00+08:00" />
<meta itemprop="dateModified" content="2021-02-21T14:33:00+08:00" />
<meta itemprop="wordCount" content="1283">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Eleven network questions"/>
<meta name="twitter:description" content="1 为什么 tcp 需要握手机制， 为什么需要三次？ 两次 四次不行么？  为什么需要握手？  TCP 的可靠性 反映出 双方如何知道对方发过去消息了？ 交换对方的 increase number 对方收到后加一 再发回去, 不丢包， 消息未成功发送会再次发送机制来确保可靠性。 tcp 是双向的 客户端和服务器端 是双工的 可以互相发消息， 和单工的区别就是 http 协议和 tcp 协议。 http 协议是单工的， 请求-应答模型，而且只能客户端发起请求，服务器端应答，客户端发起请求， 服务器端收到请求后再应答 tcp 是 client server 都可以给对方发消息， 当同时发的时候就需要知道对方的消息的序列号，否则就没法恢复说你收到了哪些消息， 序列号不能从零开始，是根据一些手段随机生成的 为了获取序列号 所以握手   为什么是三次握手？  Alice ---&gt; Bob SYNchronize with my Initial Sequence Number of X Alice &lt;--- Bob I received your syn, I ACKnowledge that I am ready for [X&#43;1] Alice &lt;--- Bob SYNchronize with my Initial Sequence Number of Y Alice ---&gt; Bob I received your syn, I ACKnowledge that I am ready for [Y&#43;1] Notice, four events are occurring: 1."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        alex&#39;s Site
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://alexgy1.github.io/posts/eleven-network-questions/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://alexgy1.github.io/posts/eleven-network-questions/&amp;text=Eleven%20network%20questions" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://alexgy1.github.io/posts/eleven-network-questions/&amp;title=Eleven%20network%20questions" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>


      <h1 class="f1 athelas mt3 mb1">Eleven network questions</h1>
      
      <p class="tracked">
          By <strong>
          
              前端关宇
          
          </strong>
      </p>
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-02-21T14:33:00+08:00">February 21, 2021</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="1-为什么-tcp-需要握手机制-为什么需要三次-两次-四次不行么">1 为什么 tcp 需要握手机制， 为什么需要三次？ 两次 四次不行么？</h2>
<ul>
<li>为什么需要握手？
<ul>
<li><strong>TCP 的可靠性</strong> 反映出 双方如何知道对方发过去消息了？ 交换对方的 increase number 对方收到后加一 再发回去, 不丢包， 消息未成功发送会再次发送机制来确保可靠性。</li>
<li>tcp 是双向的 客户端和服务器端 是双工的 可以互相发消息， 和单工的区别就是 http 协议和 tcp 协议。 http 协议是单工的， 请求-应答模型，而且只能客户端发起请求，服务器端应答，客户端发起请求， 服务器端收到请求后再应答</li>
<li>tcp 是 client server 都可以给对方发消息， 当同时发的时候就需要知道对方的消息的序列号，否则就没法恢复说你收到了哪些消息， 序列号不能从零开始，是根据一些手段随机生成的</li>
<li>为了获取序列号 所以握手</li>
</ul>
</li>
<li>为什么是三次握手？</li>
</ul>
<pre><code>Alice ---&gt; Bob    SYNchronize with my Initial Sequence Number of X
Alice &lt;--- Bob    I received your syn, I ACKnowledge that I am ready for [X+1]
Alice &lt;--- Bob    SYNchronize with my Initial Sequence Number of Y
Alice ---&gt; Bob    I received your syn, I ACKnowledge that I am ready for [Y+1]

Notice, four events are occurring:

1.Alice picks an ISN and SYNchronizes it with Bob.
2.Bob ACKnowledges the ISN.
3.Bob picks an ISN and SYNchronizes it with Alice.
4.Alice ACKnowledges the ISN.

In actuality though, the middle two events (#2 and #3) happen in the same packet. What makes a packet a SYN or ACK is simply a binary flag turned on or off inside each TCP header, so there is nothing preventing both of these flags from being enabled on the same packet. So the three-way handshake ends up being:

Bob &lt;--- Alice         SYN
Bob ---&gt; Alice     SYN ACK
Bob &lt;--- Alice     ACK
</code></pre><ul>
<li>要互相交换并接收到对方的 SYN</li>
<li>关闭时候四次， 可以半工通信</li>
</ul>
<h2 id="2-能否简单介绍一下-http-协议中缓存的处理流程">2 能否简单介绍一下 HTTP 协议中缓存的处理流程</h2>
<ul>
<li>缓存的应用流程到底是什么</li>
<li>与缓存相关的 HTTP 头部是什么</li>
</ul>
<pre><code>// $ means cache
                     http  =&gt; Proxy($) =&gt; DNS =&gt;http =&gt;Gateway(apache / nginx 反向代理服务器) =&gt; Origin Server(tomcat)
User Agent ($)=&gt;DNS=&gt;
                     http  =&gt; Proxy() =&gt;


</code></pre><ul>
<li>
<p>过期缓存也有很大的用处 会打一个摘要（服务器端生成） 如果没有修改 返回 304 节省带宽</p>
<ul>
<li>提高用户体验</li>
<li>防止高并发的请求把后面的 server 打坏</li>
</ul>
</li>
<li>
<p>http header 如何 控制过期 是很复杂的一件事</p>
</li>
<li>
<p>Cache-Control <strong>头部在请求中的值</strong></p>
<ul>
<li>max-age : 告诉服务器，客户端不会接受 Age 超过 max-age 秒的缓存</li>
<li>max-stale : 告诉服务器，即使缓存不再新鲜，但陈旧秒数没有超出 max-stale 时， 客户端仍打算使用， 若 max-stale 后没有值，无论过期多久客户端都可以使用</li>
<li>min-fresh: 告诉服务器，如果缓存距离过期还有至少 min-fresh 秒才可以使用</li>
<li>no-cache : 告诉服务器， 不能直接使用已有的缓存作为响应返回，除非带着混存条件到上游服务器端得到 304 验证码返回才可以使用现有的缓存</li>
<li>no-store： 告诉代理服务器不要对该请求的响应缓存（实际有不少不遵守该规则的代理服务器）</li>
<li>no-transform: 告诉代理服务器不要修改消息包体里面的内容</li>
<li>only-if-cached: 告诉服务器仅能返回缓存的响应，若没有缓存则返回 504 错误码</li>
</ul>
</li>
<li>
<p>Cache-Control <strong>头部在响应中的值</strong></p>
<ul>
<li>must-revalidate : 告诉客户端一旦缓存过期， 必须向服务器验证后才可以使用</li>
<li>proxy-revalidate : 与 must-revalidate 相似，但是它仅对代理服务器的共享缓存有效</li>
<li>no-cache : 告诉客户端不能直接使用缓存的响应，使用前必须在源服务器验证得到 304 状态码。 如果 no-cache 后指定头部，则若客户端的后续请求以及响应中不含有这些头则可以直接使用缓存</li>
<li>max-age : 告诉客户端缓存 age 超出 max-age 秒后则缓存过期</li>
<li>s-maxage： 与 max-age 类似 ，但仅针对共享缓存，且优先级高于 max-age 和 Expires</li>
<li>public : 无论私有或者共享缓存，皆可将该响应缓存</li>
<li>private : 表示该响应不能被代理服务器作为共享缓存使用，若 private 后指定头部， 则在告诉代理服务器不能缓存指定的头部，但可以缓存其他部分</li>
<li>no-store : 告诉下游节点不能对响应缓存</li>
<li>no-transform : 告诉代理服务器不能修改消息包体的内容</li>
</ul>
</li>
<li>
<p>RFC7234 推荐</p>
</li>
<li>
<p>浏览器对静态资源一般会加缓存， 一般是 10% of (download time - since Last-Modified )</p>
</li>
</ul>
<h2 id="3-地址栏里面键入-url-后网络世界发生了什么">3 地址栏里面键入 URL 后，网络世界发生了什么？</h2>
<ul>
<li>应用层</li>
<li>系统层 看你自己对知识掌握的程度
<blockquote>
<p>流程</p>
</blockquote>
</li>
<li>DNS 解析 根据域名得到 Ip</li>
<li>正向代理 可能有缓存 反向代理 负载均衡 后面的服务器</li>
<li>http 请求</li>
<li>tcp 三次握手
<blockquote>
<p>http 请求的编码 浏览器被实现的 你地址栏里面输入的是 url 浏览器要转换成 http 协议的编码规则</p>
</blockquote>
</li>
</ul>
<pre><code>(Method)(Path)(Version of the protocol)
(headers)

eg:

GET / HTTP/1.1
Host : developer.mozilla.org
Accept-Language : fr



</code></pre><blockquote>
<p>消息是如何传输到服务器的？</p>
</blockquote>
<ul>
<li>网络七层模型 OSI 网络分层 不分层 很麻烦 1978 年以前 tcp 是不分层的</li>
<li>tcp 解决解决两个进程之间的网络通信问题</li>
<li>ip 解决局域网内的通信</li>
</ul>
<h2 id="4-how-dnsdomain-name-system-works">4 how DNS(Domain Name System) works</h2>
<ul>
<li>
<p>Computers and other devices communicate using ip address to identify each other on the internet like<code>209.85.129.103</code></p>
</li>
<li>
<p>People don&rsquo;t remember ip address so they use words like<code>www.google.com</code></p>
</li>
<li>
<p>The DNS brings teh two together and gets you to your destination.</p>
</li>
<li>
<p>when user enter a url(<code>www.google.ca</code>) in the browser on a computer . <strong>The search for the ip address starts!</strong></p>
</li>
<li>
<p>(the DNS Resolver will ask browser and OS first) if they have the domain to ip record or cache if they have. return it</p>
</li>
<li>
<p>Or based on the OSI. thr DNS Rosolver will ask the <strong>ROOT Server</strong> to search for <code>.ca</code> name servers. then will give the ip address of the <code>.ca</code> after get this ip. the Resolver will keep on searching for the <code>google.ca</code> &rsquo;s ip address. when have the result. the ip address identified.</p>
</li>
<li>
<p>After connection to the ip address of the webserver. the data is download from that source</p>
</li>
<li>
<p>(what browser done after doing this ?) return the ip address to the os and browser . they will cache it . if next time user enter the same url . the browser will return it directly form cache. then the browser will keep build a TCP connection and send HTTP request . after the server given back some HTML CSS JS files . the brower will keep render it and then show them to the user.</p>
</li>
<li>
<p><a href="https://howdns.works/ep1/">how-dns-works</a></p>
</li>
</ul>
<h2 id="5-http-长链接有哪些优点">5 http 长链接有哪些优点？</h2>
<blockquote>
<p>实际上在考察 tcp 协议</p>
</blockquote>
<ul>
<li>
<p>http 长链接和短链接是怎么区分的？本质上是 TCP 的长短连接 , HTTP 是应用层协议， TCP 是传输层协议。IP 协议主要解决网络路由和寻址问题，TCP 协议主要解决如何在 IP 层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。TCP 有可靠，面向连接的特点。 根据 http header <strong>connection</strong> 字段的值区分， connection : keep-alive 是长连接，</p>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接</p>
<p>http1.0 默认短连接
http1.1 默认长连接</p>
<p>短连接的操作步骤是：</p>
<ul>
<li>建立连接——数据传输——关闭连接&hellip;建立连接——数据传输——关闭连接</li>
</ul>
<p>长连接的操作步骤是：</p>
<ul>
<li>建立连接——数据传输&hellip;（保持连接）&hellip;数据传输——关闭连接</li>
</ul>
<p>长连接可以省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测 TCP 连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client 端一般不会主动关闭它们之间的连接，Client 与 server 之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server 早晚有扛不住的时候，这时候 server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致 server 端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>
<p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在 TCP 的建立和关闭操作上浪费时间和带宽。</p>
<p>长连接和短连接的产生在于 client 和 server 采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p>
</li>
<li>
<p>减少握手次数</p>
</li>
<li>
<p>减少慢启动的影响 ,为什么有慢启动，是因为即使 client ,server 都有足够的内存来处理，但是收到网络带宽的限制，不能一下让子被占满，每次短连接，都会经历慢启动的过程，慢启动是指每次 TCP 接收窗口收到确认时都会增长。 增加的大小就是已确认段的数目。 这种情况一直保持到要么没有收到一些段，要么窗口大小到达预先定义的阈值。 如果发生丢失事件，TCP 就认为这是网络阻塞，就会采取措施减轻网络拥挤，</p>
<blockquote>
<p>有什么缺点？</p>
</blockquote>
</li>
</ul>
<h2 id="6-介绍一下-close_wait-状态产生的原因">6 介绍一下 CLOSE_WAIT 状态产生的原因？</h2>
<ul>
<li>什么是 CLOSE_WAIT 是四次握手关闭 TCP 连接的时候，产生的一种状态,特别有用，出现这个的时候就说明程序有 bug 了， 要么是中间件的要么是应用层的，一定是出现了 bug 了。</li>
<li>ClOSE_WAIT 出自 TCP 的状态机，<a href="https://tools.ietf.org/html/rfc793">rfc793</a></li>
</ul>
<pre><code>                                           Transmission Control Protocol
                                                Functional Specification




                              +---------+ ---------\      active OPEN
                              |  CLOSED |            \    -----------
                              +---------+&lt;---------\   \   create TCB
                                |     ^              \   \  snd SYN
                   passive OPEN |     |   CLOSE        \   \
                   ------------ |     | ----------       \   \
                    create TCB  |     | delete TCB         \   \
                                V     |                      \   \
                              +---------+            CLOSE    |    \
                              |  LISTEN |          ---------- |     |
                              +---------+          delete TCB |     |
                   rcv SYN      |     |     SEND              |     |
                  -----------   |     |    -------            |     V
 +---------+      snd SYN,ACK  /       \   snd SYN          +---------+
 |         |&lt;-----------------           ------------------&gt;|         |
 |   SYN   |                    rcv SYN                     |   SYN   |
 |   RCVD  |&lt;-----------------------------------------------|   SENT  |
 |         |                    snd ACK                     |         |
 |         |------------------           -------------------|         |
 +---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+
   |           --------------   |     |   -----------
   |                  x         |     |     snd ACK
   |                            V     V
   |  CLOSE                   +---------+
   | -------                  |  ESTAB  |
   | snd FIN                  +---------+
   |                   CLOSE    |     |    rcv FIN
   V                  -------   |     |    -------
 +---------+          snd FIN  /       \   snd ACK          +---------+
 |  FIN    |&lt;-----------------           ------------------&gt;|  CLOSE  |
 | WAIT-1  |------------------                              |   WAIT  |
 +---------+          rcv FIN  \                            +---------+
   | rcv ACK of FIN   -------   |                            CLOSE  |
   | --------------   snd ACK   |                           ------- |
   V        x                   V                           snd FIN V
 +---------+                  +---------+                   +---------+
 |FINWAIT-2|                  | CLOSING |                   | LAST-ACK|
 +---------+                  +---------+                   +---------+
   |                rcv ACK of FIN |                 rcv ACK of FIN |
   |  rcv FIN       -------------- |    Timeout=2MSL -------------- |
   |  -------              x       V    ------------        x       V
    \ snd ACK                 +---------+delete TCB         +---------+
     ------------------------&gt;|TIME WAIT|------------------&gt;| CLOSED  |
                              +---------+                   +---------+

                      TCP Connection State Diagram
                               Figure 6.


</code></pre><ul>
<li>TCP 一旦建立起来就不区分谁是 Client 或谁是 Server 了， 我们区分的是谁先主动关。
<ul>
<li>主动端</li>
<li>被动关闭端</li>
</ul>
</li>
<li>可以通过 <code>netstat</code> 查看</li>
<li>延展就是对 linux sys 的一些参数的精确控制</li>
</ul>
<h2 id="7-能介绍一下多播组播和广播是怎么实现的么">7 能介绍一下多播（组播和广播）是怎么实现的么？</h2>
<blockquote>
<p>单播，广播，组播。</p>
</blockquote>
<p>-　 　单播（Unicast）传输：在发送者和每一接收者之间需要单独的数据信道。 如果一台主机同时给很少量的接收者传输数据，一般没有什么问题。但如果有大量主机希望获得数据包的同一份拷贝时却很难实现。 这将导致发送者负担沉重、延迟长、网络拥塞；为保证一定的服务质量需增加硬件和带宽。</p>
<p>-　　组播（Multicast）传输：它提高了数据传送效率。减少了主干网出现拥塞的可能性。组播组中的主机可以是在同一个物理网络， 也可以来自不同的物理网络（如果有组播路由器的支持）。</p>
<p>-　 　广播（Broadcast）传输：是指在 IP 子网内广播数据包，所有在子网内部的主机都将收到这些数据包。 广播意味着网络向子网主机都投递一份数据包，不论这些主机是否乐于接收该数据包。然而广播的使用范围非常小， 只在本地子网内有效，因为路由器会封锁广播通信。广播传输增加非接收者的开销。</p>
<blockquote>
<p>好处 单播发 1GB 同时给 100 个机器发，需要主机 CPU 复制 100 份 ,而使用多播是网络设备(交换机和路由器实现的)， 对发送端有巨大的性能提升，以及网络带宽占用少， 华为做了这件事</p>
</blockquote>
<ul>
<li>延伸</li>
<li>为什么可以多播？ 就要看 mac 和 tcp 的特点再展开了。</li>
</ul>
<h2 id="8-服务器的最大并发连接数是多少">8 服务器的最大并发连接数是多少？</h2>
<ul>
<li>
<p>是由 TCP 四元组决定的， 端口是和进程关联起来的， 没有端口就没法关联到进程</p>
</li>
<li>
<p>(源 IP 地址)（源端口) (目标 IP 地址) (目标端口) 系统用一个 4 四元组来唯一标识一个 TCP 连接：{local ip, local port,remote ip,remote port}。</p>
<blockquote>
<p>最大 tcp 连接数约为 2 的 32 次方（ip 数）×2 的 16 次方（port 数），也就是 server 端单机最大 tcp 连接数约为 2 的 48 次方。</p>
</blockquote>
</li>
<li>
<p>延伸：</p>
<ul>
<li>
<p>如何实现高并发？</p>
<ul>
<li>
<p>垂直扩展 ：</p>
<ul>
<li>硬件方面： 提高单机硬件性能，增加 cpu 核数， 升级成更好的网卡，升级成更好的硬盘，扩充内存</li>
<li>软件方面： 利用缓存，减少 I/O 次数，利用异步增加单服务吞吐量，使用无锁的数据结构来减少响应时间</li>
</ul>
</li>
<li>
<p>水平扩展：(单机性能有限，互联网分布式架构设计高并发终极解决方案还是水平扩展。)</p>
<ul>
<li>
<p>分层架构： 端(browser webapp ios app android app ) =&gt; 反向代理(nginx) =&gt; webServer(return html js css or json xml ) =&gt; service =&gt; database(sql, nosql)(master slave) or =&gt;cache</p>
</li>
<li>
<p>反向代理的水平扩展是通过<strong>DNS 轮询</strong>实现的，当 nginx 成为瓶颈的时候，只要增加服务器数量，新增 nginx 服务的部署，增加一个外网 ip，就能扩展反向代理层的性能，做到理论上的无限高并发。</p>
</li>
<li>
<p>webServer 的水平扩展是通过<strong>nginx</strong>实现的，通过修改 nginx.conf，可以设置多个 web 后端。当 web 后端成为瓶颈的时候，只要增加服务器数量，新增 web 服务的部署，在 nginx 配置中配置上新的 web 后端，就能扩展站点层的性能，做到理论上的无限高并发。</p>
</li>
<li>
<p>service 服务层的水平扩展，是通过“服务连接池”实现的。</p>
</li>
<li>
<p>数据层的水平扩展，将原本存储在一台服务器上的数据（缓存，数据库）水平拆分到不同服务器上去，以达到扩充系统性能的目的。</p>
<ul>
<li>
<p>按照<strong>范围水平拆分</strong> 2W 分成两台机器存 一台 [1-1kw） 另一台 [1kw-2W] ,这个方案的好处是：</p>
<p>（1）规则简单，service 只需判断一下 uid 范围就能路由到对应的存储服务；</p>
<p>（2）数据均衡性较好；</p>
<p>（3）比较容易扩展，可以随时加一个 uid[2kw,3kw]的数据服务</p>
<p>不足是：
1） 请求的负载不一定均衡，一般来说，新注册的用户会比老用户更活跃，大 range 的服务请求压力会更大；</p>
</li>
<li>
<p>按照<strong>哈希水平拆分</strong>, user0 库存奇数的 user1 库存偶数的
这个方案的好处是：</p>
<p>（1）规则简单，service 只需对 uid 进行 hash 能路由到对应的存储服务；</p>
<p>（2）数据均衡性较好；</p>
<p>（3）请求均匀性较好；</p>
<p>不足是：</p>
<p>（1）不容易扩展，扩展一个数据服务，hash 方法改变时候，可能需要进行数据迁移；</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Linux 下的高并发优化？</p>
</li>
</ul>
<h2 id="9-tcp-和-udp-协议如何选择">9 TCP 和 UDP 协议如何选择？</h2>
<blockquote>
<p>选择不同的协议要根据不同的使用场景。好像啥也没说一样。</p>
</blockquote>
<ul>
<li>
<p>UDP (视频直播 要求实时性高 可以丢包)</p>
<ul>
<li>一对多通讯</li>
<li>效率高</li>
<li>简单</li>
<li>实时性更好
<ul>
<li>无队头阻塞问题</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TCP （不想再应用层重新实现下面四点的时候，直接使用 TCP 提供的这四点）</p>
<ul>
<li>是一个字符流协议，意味着可以传递任意长度消息 （一个字节 或者 500GB）</li>
<li><strong>可靠</strong></li>
<li>流量控制(sender receiver 的滑动窗口)</li>
<li>拥塞控</li>
</ul>
</li>
</ul>
<h2 id="10-tslssl-如何保障信息安全的">10 TSL/SSL 如何保障信息安全的？</h2>
<ul>
<li>PKI 证书体系</li>
<li>密钥交换协议（如何传输密钥）</li>
<li>对称加密算法 (密钥)</li>
</ul>
<h2 id="11-http2-协议有哪些优点">11 HTTP2 协议有哪些优点？</h2>
<blockquote>
<p>先要知道 http1.0 http1.1 有哪些缺点？</p>
</blockquote>
<ul>
<li>header 太长了 什么都往里面设置 什么都往 cookie 里面设置 浪费带宽</li>
<li>长连接的情况不支持多路复用</li>
<li>chrome 下最多 6 个 tcp 连接<a href="https://www.cnblogs.com/sunsky303/p/8862128.html">2</a></li>
</ul>
<blockquote>
<p>http2 的优点</p>
</blockquote>
<ul>
<li>
<p>多路复用、消息推送</p>
</li>
<li>
<p>HPACK 编码 通过下面四种手段可以将 header 缩小为原来的 1/2 左右</p>
<ul>
<li>动态表</li>
<li>表态表</li>
<li>静态 Huffman</li>
<li>整数编码</li>
</ul>
</li>
<li>
<p>stream 优先级</p>
<ul>
<li>html css js video 等请求的资源返回的优先级 也会影响后面的代理服务器</li>
<li>依赖 vue react 等框架的时候，要先加载这些框架，再加载用户写的 js</li>
</ul>
</li>
</ul>
<hr>
<h2 id="why-do-we-need-a-3-way-handshake-why-not-just-2-way-1httpsnetworkengineeringstackexchangecomquestions24068why-do-we-need-a-3-way-handshake-why-not-just-2-way">why-do-we-need-a-3-way-handshake-why-not-just-2-way <a href="https://networkengineering.stackexchange.com/questions/24068/why-do-we-need-a-3-way-handshake-why-not-just-2-way">1</a></h2>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://alexgy1.github.io" >
    &copy;  alex's Site 2021 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
